import Square from "../Square.js";
import { IllegalMoveError, GameError } from "../error.js";
import { KING } from "../constants.js";
import { oppositeColor } from "../../utilities.js";
import ChessEngine from "../ChessEngine.js";


class ChessPiece {
  constructor(color, position, gameEngine = null) {
    this.game = null;
    /** @type {string} */
    this.color = color;
    /** @type {Square} */
    this.pos = position;
    /**
     * type of piece (ie. King, Bishop, Pawn, etc...)
     * 
     * TODO: replace this with checks on instanceof {class}
     *  we shouldn't need to store the type in a property.
     *  
     * @type {string} 
     * */
    this.type = null;

    /**
     * legal moves for a piece according to board state 
     * @type {Square[]} 
     * */
    this.legalMoves = [];
    /**
     * board squares targetted by a piece
     * @type {Square[]} 
     * */
    this.targets = [];
    /**
     * List of the opposing pieces' possible moves to resolve a check situation generated by a chess piece.
     * 
     * Should be empty if the piece is not invlolved in a chess situation
     * @type {Square[]}
     */
    this.checkBreakers = [];

    if (gameEngine instanceof ChessEngine) {
      this.setGame(gameEngine);
    }
  }

  /**
   * updates a piece's legal moves and targets according to board state
   */
  update() {
    this.legalMoves = [];
    this.targets = [];
    this.checkBreakers = [];
  }

  /**
   * access the game engine property of the chess piece 
   * @returns {ChessEngine}
   * @throws GameError
   */
  getGame() {
    if (!(this.game instanceof ChessEngine)) {
      throw new GameError(`Chesspiece ${this} is not in game`);
    }
    return this.game;
  }

  /**
   * sets the chess piece's game property 
   * @param {ChessEngine} gameEngine 
   * @throws TypeError
   */
  setGame(gameEngine) {
    if (!(gameEngine instanceof ChessEngine)) {
      throw new TypeError(`${gameEngine} is not a ChessEngine`);
    }
    this.game = gameEngine;
  }

  /**
   * moves a chess piece on the board
   * @throws 
   *  - TypeError
   *  - IllegalMoveError
   * @param {Square} square
   * @returns {ChessPiece} taken piece or null
   */
  move(square) {
    const board = this.getGame().board;
    if (!this.legalMoves.find((move) => move?.name === square.name)) {
      throw (new IllegalMoveError(`${this.pos.name} to ${square.name}`));
    }

    const destinationContent = board[square.x][square.y];

    if (destinationContent instanceof ChessPiece) {
      this.take(destinationContent);
    }

    board[this.pos.x][this.pos.y] = null;
    board[square.x][square.y] = this;
    this.pos = square;

    return destinationContent;
  }

  /**
   * sets a piece's position at target piece's position on the board after removing target piece.
   * @param {ChessPiece} target - target piece
   * @returns
   * @throws {IllegalaMoveError} when attempting to take a piece of the same color.
   */
  take(target) {
    if (!(target instanceof ChessPiece)) {
      return;
    }
    if (target.color === this.color) {
      throw (new IllegalMoveError(`${this.pos.name} to ${target.pos.name}`));
    }
    const game = this.getGame();
    const index = game.pieces[target.color].indexOf(target);

    game.board[target.pos.x][target.pos.y] = null;
    game.pieces[target.color].splice(index, 1);
    game.taken[target.color] = target;
  }

  /**
   * updates list of moves for opposing pieces that will break a check situation generated by current piece.  
   */
  updateCheckBreakers() {
    const opposingKing = this.getGame().kings[oppositeColor(this.color)];

    if (this.targets.some(target => opposingKing.pos.name === target.name)) {
      this.checkBreakers = [this.pos];
    } else {
      this.checkBreakers = [];
    }
  }

  /**
   * filters this piece's legal moves to only include moves that will resolve a check situation
   * when the king of this piece's color is checked
   */
  updateLegalMovesWhenChecked() {
    const game = this.getGame();
    if (!game.isKingChecked(this.color)) return;

    this.legalMoves = this.legalMoves.filter(move => {
      for (const attacker of game.checks[this.color]) {
        for (const interception of attacker.checkBreakers) {
          if (move.name === interception.name) {
            return true;
          }
        }
      }
      return false;
    });

    return;
  }

  /**
   * utility method
   * if move is legal, will push to this.legalMoves 
   * @param {0} x : column in the chess board
   * @param {1} y : row in the chess board
   * @returns
   *     - true if movement should continue
   *     - false if movement should stop
   */
  legalBoardSpace(x, y) {
    const game = this.getGame();
    const space = new Square(x, y);

    if (!game.inBounds(space)) {
      return false;
    }
    this.targets.push(space);
    const target = game.getSquare(space);

    if (target instanceof ChessPiece && target.color === this.color) {
      return false;
    }

    this.legalMoves.push(space);

    if (target instanceof ChessPiece && target.type !== KING) {
      return false;
    }

    return true;
  }
}

export default ChessPiece;